--- Prozesse, Threads in Linux/Unix

Jeder Prozess in Linux hat einen eigenen (privaten) virtuellen
Adressraum zur Verfügung, dessen Größe nur von der
Prozessorarchitektur abhängt (auf x86: 4 GB). Der (virtuelle) Speicher
innerhalb dieses Adressraums hat Speicherseiten (beliebiger
Startadresse und Größe, auf x86 hardwarebedingt auf 4-KB-Grenzen
ausgerichtet) eingeblendet, die von den verschieden Bibliotheken, die
der Prozess gebunden hat, stammen. Den Speicherseiten sind
Zugriffsrechte (read, write, execute) zugeordnet. Diese
Rechteinformationen stammen ebenfalls aus den Bibliotheksdateien, aus
denen die jwlg. Seiten stammen. In /proc/<pid>/maps sind all diese
Informationen fuer den Prozess mit der PID <pid> aufgelistet.

Codesegmente haben i.d.R. nur x- (execute-) Rechte, Datensegmente
haben rw- (Lese-und Schreib-) Rechte. Da Codesegmente nicht
beschrieben werden können und ihren Inhalt demzufolge nie ändern,
können sie zwischen allen Prozessen, in deren Adressräumen sie
eingeblendet sind, geshared werden, d.h. sie belegen nur einmal
physikalisch Speicher. Das ist allerdings nur möglich, wenn die
Bibliothek, zu der die entspr. Codesegmente gehören, mit der
gcc-Option -fPIC compiliert wurde (siehe unten).

Datensegmente (sie halten prozessglobale Variablen) haben rw-
(Lese/Schreib-) Rechte, weshalb sie nicht zwischen mehereren Prozessen
geshared werden, *es sei denn*, die Prozesse sind im Spezialfall
Threads (siehe unten). Im Normalfall hat aber jeder Prozess seine
eigene Kopie der Datensegmente.

Ein Prozess kann in Linux (und jedem POSIX-kompatiblen System) mit der
bekannten Funktion fork(2) einen Subprozess erzeugen. Dabei handelt es
sich dann um einen Prozess im traditionellen (UNIX-)Sinn (d.h. keinen
Thread). Er bekommt also eine eigenständige Kopie der rw- (Daten-)
Segmente des Elternprozesses, d.h. seine globale Variablen werden vom
Elternprozess kopiert, können dann aber unabhängig von diesem geändert
werden.

Ein Thread wird in Linux (und jedem POSIX-kompatiblen System)
i.d.R. über die entspr. POSIX-konforme Funktion (pthread_create(3))
erzeugt. Ein Thread ist in Linux ein Prozess, der aber im Gegensatz zu
"traditionellen" Prozessen seine Datensegmente mit dem Parent-Prozess
teilt. Das bedeutet, dass Parent- und Child-Prozess dieselben globalen
Variablen sehen und konkurrierend auf sie zugreifen können. Dies kann
bekanntermaßen zu Problemen führen, weshalb Funktionen oder ganze
Bibliotheken i.d.R. explizit thread-safe (i.e. reentrant) gemacht
werden müssen. Dies erfolgt dadurch, dass die entspr. Funktion
entweder keine globalen Variablen benutzt oder jeder Zugriff darauf
synchronisiert (z.B. über einen Mutex) erfolgt. Lokale Variablen
(innerhalb von Funktionen) werden auf dem Stack des Prozesses/Threads
gespeichert. Der Stack wird nie zwischen mehreren Prozessen/Threads
geshared (jeder Prozess/Thread hat genau ein eigenes, mit niemandem
gesharetes rw-Stacksegment (TODO: verify)), sodass Zugriffe auf lokale
Variablen nicht synchronisiert werden müssen.

Speziell in Linux erfolgt die Erzeugung sowohl von traditionellen
Prozessen als auch von Threads über den Syscall clone(2). Die
Unterscheidung erfolgt dabei über den 2. Parameter an clone(). Sowohl
fork(3) als auch pthread_create(3) sind in Linux über clone(2)
implementiert.


 


-- gcc -fPIC

Die Option -fPIC ("positon-independent code") weist gcc an,
Codesegmente zu erzeugen, die der Programmlader des Betriebssystems
später an jede beliebige Stelle innerhalb des virtuellen Speichers
laden kann, ohne dass dazu der Code angepasst ("reloziert",
"relocated") werden müsste. Das Laden eines Codesegments an variable
Adressen kann nämlich nötig werden, wenn das Segment in mehrere
Prozesse eingeblendet werden soll, wobei in einigen von denen
bestimmte Adressbereiche schon belegt sind. Wurde die Option "-fPIC"
beim Compilieren *nicht* angegeben, muss der Programmlader das Segment
"relozieren", d.h. er muss bestimmte Teile des Codes (absolute
Sprungziele und dergleichen) anpassen. Das führt dazu, dass meherere
"Varianten" des Codesegment im phys. Speicher gehalten werden
müssen. Deshalb: -fPIC beim Compilieren von Shared Libraries!

Technisch wird -fPIC so realisiert, dass ein zusätzliches
Prozessorregister belegt wird, das als Basisregister für alle Sprünge
usw. benutzt wird. Auf x86 führt das wegen des chronischen
Registermangels zu im Schnitt ca. 10-15% langsamerem Code, auf
"richtigen" Architekturen (RISC) ist dagegen kaum etwas zu spüren...

I.d.R. lohnt sich -fPIC trotzdem auch auf x86.
