<html>
<!-- -*- html -*- -->





<head>
  <title> ./internet/ipv6/bind-to-prefix.txt </title>
</head>

<body>

  <h1> <a href="../../.">.</a>/<a href="../.">internet</a>/<a href=".">ipv6</a>/bind-to-prefix.txt </h1>

  <a href="bind-to-prefix.txt">download original</a>

  <pre>
http://kerneltrap.org/mailarchive/linux-netdev/2010/9/27/6285917

03:01 &lt; multi_io&gt; wouldn't IPv6 at some point require changes to the IP stack and the socket APIs to enable new applications?
03:02 -!- titankiller2 is now known as titankiller
03:02 &lt; patdk-lap&gt; not really
03:02 &lt; patdk-lap&gt; the changes to the ip stack where done years and years ago
03:02 &lt; multi_io&gt; e.g. the ability to listen to billions of IP addresses at the same time :)
03:02 &lt; patdk-lap&gt; it's just applications not using them
03:03 &lt; rewt&gt; why would you listen to billions of IP addresses at the same time?
03:03 &lt; patdk-lap&gt; cause your mentally insane?
03:05 &lt; multi_io&gt; dunno... say you want to write an application that maps each ...hm... street light in a city to a unique IP
03:05 -!- Logan_A [logan@zer0drive.lawarias.srb2.org] has joined #ipv6
03:05 &lt; multi_io&gt; ping succeeds if the light is on :P
03:05 &lt; patdk-lap&gt; that is backwards
03:05 &lt; rewt&gt; still don't see the issue; the server would still have 1 ip
03:06 &lt; multi_io&gt; or, maybe, you can then send UDP packet to each light to do something with it
03:06 &lt; patdk-lap&gt; the light would have the ip then
03:06 &lt; multi_io&gt; or even open a TCP connection to each light (not all at the same time)
03:06 &lt; patdk-lap&gt; I totally don't get why you would even bother with something like that
03:07 &lt; patdk-lap&gt; that goes into, why do people want to put power meters on the internet? seems stupid to me
03:07 &lt; rewt&gt; so the power company can read it w/o sending a guy out
03:07 &lt; multi_io&gt; patdk-lap: you may want to aggregate/manage this all in one userspace application running on one machine
03:07 &lt; patdk-lap&gt; rewt, they can do that now
03:07 &lt; rewt&gt; without connectivity to it?
03:07 &lt; patdk-lap&gt; multi_io, yes, but why does that require the lights to be on the *internet*
03:08 &lt; patdk-lap&gt; rewt, who ever said the only way to connect two things together in the world is the internet?
03:08 &lt; Xenith&gt; I'd want my power meter to be accessable over the internet.
03:08  * patdk-lap shuts off xenith's power :)
03:08 &lt; rewt&gt; it's cheaper for them to use existing infrastructure than to make a new one just for the power meters
03:08 -!- LoganA [logan@zer0drive.lawarias.srb2.org] has quit [Ping timeout: 260 seconds]
03:08 &lt; Xenith&gt; patdk-lap: And why would that work?
03:08 &lt; patdk-lap&gt; they already have one for power meters
03:08 &lt; rewt&gt; not everywhere
03:08 &lt; Xenith&gt; Why would ones power meter ACCEPT COMMANDS over the public internet? :)
03:09 &lt; Xenith&gt; I already have a smart meter. Sadly I can't access it.
03:09 &lt; patdk-lap&gt; xenith, that is the whole goal
03:09 &lt; patdk-lap&gt; ya, you can't
03:09 &lt; patdk-lap&gt; or atleast yet
03:09 &lt; multi_io&gt; I'm just wondering whether the current socket APIs are really adequate to enable new kinds of applications that may become 
                  possible when millions of IPs are readily available locally
03:09 -!- ym [ym@cpe-74-78-137-112.twcny.res.rr.com] has joined #ipv6
03:09 &lt; Xenith&gt; I'd rather have mine accessible to gather aggregate stats or see what my current usage is.
03:09 &lt; Xenith&gt; Of course, I already have that.
03:09 &lt; patdk-lap&gt; xenith, that is very easy to do
03:10 &lt; Xenith&gt; I just can't see them.
03:10 &lt; rewt&gt; multi_io, it's only limited by memory
03:10 &lt; patdk-lap&gt; no power meter needed
03:10 &lt; patdk-lap&gt; I don't see the point of using an ip, just cause we have them available
03:10 &lt; patdk-lap&gt; give each light an ipv6 address, on a single computer
03:10 &lt; ym&gt; Hey guys, just curious if seeing "::ffff:138.187.130.90" on a traceroute6 should be concerning. All the addresses are "proper" v6 
            ones, except that ::ffff:, around hop 7 or so.
03:11 &lt; patdk-lap&gt; you still have custom hardware from that computer to each light to check it's status
03:11 -!- PhotoJim is now known as PhotoJim_
03:11 &lt; patdk-lap&gt; it would be so much easier to just make a simple like, webpage that you just request, is light xxxx on?
03:11 &lt; patdk-lap&gt; ym, that is an ipv4 address
03:11 &lt; ym&gt; yeah, so why is my traceroute6 routing over it?
03:12 &lt; rewt&gt; ask the network admin of the network it's in
03:12 &lt; ym&gt; it's not proper, right?
03:12 &lt; Xenith&gt; ym: ipv4 mapped ipv6 address. Silly thing to show up in a traceroute. Probably a misconfiguration.
03:12 -!- PhotoJim [~Jim@dalby.ip4.photojim.ca] has joined #ipv6
03:13 &lt; ym&gt; IPv6 switch.ch times out on a connect on port 80, and that's the only weird thing I see in the traceroute.
03:13 &lt; Xenith&gt; patdk-lap: How would the server talk to each light?
03:13 &lt; multi_io&gt; patdk-lap: yeah, it easier to make a web page exactly because there are APIs for it
03:13 &lt; patdk-lap&gt; I dunno, but he said all the ip's would exist on the server, not lightpd
03:13 -!- PhotoJim [~Jim@dalby.ip4.photojim.ca] has quit [Client Quit]
03:13 &lt; patdk-lap&gt; the lights
03:13 &lt; Xenith&gt; Just because something has an ip address doesn't mean its accessible to the entire world.
03:14 &lt; patdk-lap&gt; xenith, ya, human error never happens
03:14 &lt; Xenith&gt; sigh
03:14 &lt; Xenith&gt; That's a "won't someone think of the children" argument.
03:14 -!- PhotoJim [~Jim@dalby.ip4.photojim.ca] has joined #ipv6
03:14 &lt; patdk-lap&gt; hehe :)
03:15  * patdk-lap gives each kid a /64 :)
03:15 &lt; Xenith&gt; "Any man can be a child molester, so we should keep EVERY MAN away from the children!"
03:15 &lt; multi_io&gt; e.g. you wan write a web server that can accept HTTP requests with millions of differens request paths /lamp_277373 etc., but 
                  you can't write apps that can receive IP packets on millions of different addresses if you wanted to map each light to an 
03:15 &lt; patdk-lap&gt; I wonder how many generations that would last
03:15 &lt; multi_io&gt; but maybe the example isn't brilliant anyway
03:15 &lt; Xenith&gt; multi_io: You wouldn't design a system like that.
03:15 -!- PhotoJim_ [~Jim@dubbo.ip4.photojim.ca] has quit [Quit: Still here, just changed hosts.  Impending power failure chez moi :)]
03:15 &lt; rewt&gt; multi_io, no, because in your example everything would only need a single ip
03:16 &lt; Xenith&gt; You could have a single server respond to an entire /64, but it'd probably run out of resources pretty quickly.
03:16 &lt; rewt&gt; depending on how you do it
03:16 &lt; patdk-lap&gt; I think using the network stack for something like that would be wrong anyways
03:16 &lt; multi_io&gt; Xenith: why?
03:16 &lt; patdk-lap&gt; just use packet capture in your program to get it
03:17 &lt; Xenith&gt; multi_io: Why what?
03:17 &lt; patdk-lap&gt; no need to bother with all the ip's
03:17 &lt; Xenith&gt; ....?
03:19 &lt; JayEye&gt; if you assign an IP address to each lamp, why have *one* server process all of the requests? let the lamps each process its own 
                request
03:19 &lt; JayEye&gt; if you want one server, then pass it as a parameter to some call you make, don't encode it in the address
03:20 &lt; multi_io&gt; Xenith: why would you run out of resources? (you will if you assign a million IPs to an interface and try to bind to all of 
                  them, but that's why the socket API would need to be extended in some more fundamental way)
03:21 -!- Ganymede [~Ganymede@unaffiliated/ganymede] has joined #ipv6
03:21 &lt; patdk-lap&gt; the socket api needs to know what ip and port each program is listening on
03:21 &lt; multi_io&gt; from the kernel's perspective, it shouldn't make much of a difference for teh resource consumption whether you're listening to 
                  one address or all addresses in a /64.
03:21 &lt; patdk-lap&gt; that means allocating memory for each one
03:22 &lt; Xenith&gt; The socket api is fine. It can handle binding to as many IPs at it needs to.
03:22 &lt; patdk-lap&gt; at some point you will run out of ram
03:22 &lt; Xenith&gt; You might just run out of memory at some point.
03:22 &lt; Xenith&gt; multi_io: Not true. You have to allocate memory for all of those structs.
03:22  * patdk-lap imagings what swapping out that data would do :)
03:22 -!- FireEgl [FireEgl@2001:470:e056:1:dd39:17c9:fd98:9548] has quit [Ping timeout: 260 seconds]
03:22 &lt; multi_io&gt; patdk-lap: it would only know which prefix each program is listening on
03:23 &lt; Xenith&gt; Um, no.
03:23 &lt; Xenith&gt; A prefix denotes a network.
03:23 &lt; Mekkis&gt; wouldn't you need a larger address bus?
03:24 &lt; ym&gt; Can someone who isn't using he.net please pastebin me a traceroute6 to www.switch.ch?
03:25 &lt; multi_io&gt; you could implement that any way you want. If the kernel passes all packets whose target address are in a specific /64 to the 
                  userspace, that /64 is no longer a "network".
03:25 &lt; Xenith&gt; Yes. That /64 becomes an "address"
03:25 &lt; rewt&gt; if you listen on ::, it listens on all bound ips
03:25 &lt; Xenith&gt; And suddenly you've halved the v6 space.
03:26 &lt; patdk-lap&gt; ym, use a routeserver
03:27 &lt; Ganymede&gt; http://www.cisco.com/assets/sol/sp/ipv6_discovery/ &lt;-- Can someone help me extract the URL of the actual video so I can DL it 
                  via wget or something?
03:27 &lt; rewt&gt; ym, google for ipv6 looking glass, and pick a result to traceroute6 from
03:28 &lt; multi_io&gt; Xenith: what do you mean? You get a /56 anyway from you ISP :P
03:28 &lt; Xenith&gt; Ganymede: http://www.cisco.com/assets/sol/sp/ipv6_discovery/flvplayer.swf
03:28 &lt; Mekkis&gt; http://www.cisco.com/assets/sol/sp/ipv6_discovery/video.flv
03:29 &lt; Xenith&gt; multi_io: What does that have to do with anything?
03:29 &lt; Ganymede&gt; Mekkis, Thanks. For some reason, my Firefox download couldn't find that.
03:30 &lt; Ganymede&gt; It's also a pretty cool video if anyone hasn't seen it.
03:30 &lt; Ganymede&gt; Firefox addon*
03:33 &lt; Xenith&gt; multi_io: I suggest you read up on the theory and practice behind TCP/IP.
03:38 &lt; p1mrx&gt; it would certainly be possible to run an HTTP server on every address in a /64, with proper kernel support
03:38 &lt; p1mrx&gt; you could probably do it all in userspace using tun/tap stuff
03:39  * fly23_ just imagines a whole /64 joining this channel
03:40 &lt; p1mrx&gt; well, obviously you can't have simultaneous connections to every address, because each connection requires state
03:40 &lt; multi_io&gt; Xenith: "&lt; Xenith&gt; multi_io: Not true. You have to allocate memory for all of those structs." -- as I said, you wouldn't have 
                  one struct per address with proper kernel support (as p1mrx suggests)
03:40 &lt; p1mrx&gt; you would have one struct per active connection, but you don't need one struct per listening address, if it's implemented right.
03:41 &lt; multi_io&gt; you're gonna have a resource problem of just the same proportion if you have just one IP and a million simultaneous 
                  connections to it
03:41 &lt; patdk-lap&gt; yep
03:41 &lt; patdk-lap&gt; that is why ulimit -n exists
03:41 &lt; multi_io&gt; (let's forget for a moment that you can only have 65000 simultaneous TCP connections to the same IP anyway)
03:41 &lt; p1mrx&gt; essentialy what you'd be doing is listening on a 64-bit IP address, with a 64-bit cookie value.
03:42 &lt; patdk-lap&gt; multi_io, you can have many many more
03:42 &lt; Xenith&gt; I should point out that systems do currently handle millions of simultaneous connections.
03:42 &lt; patdk-lap&gt; sourceip*sourceport*destport to the same ip limit
03:43 &lt; Xenith&gt; Also, just because you have suddenly have a lot more IPs per network doesn't mean you'll suddenly have the same growth of 
                simultaneous connections
03:43 &lt; multi_io&gt; so anyway, the number of IPs by itself isn't gonna be a resource problem if you have proper kernel/socket API support
03:43 &lt; patdk-lap&gt; so, 2^64 tcp connections limit per dest ip, using ipv4
03:45 &lt; Xenith&gt; I'm done here.
03:45 &lt; multi_io&gt; patdk-lap: right, ok
03:45 &lt; Ganymede&gt; Which systems currently handle millions of connections? (Not asking which are capable of doing so, but which actually do so?)
03:46 &lt; patdk-lap&gt; only things I can think of is loadbalancers/firewalls/routers
03:46 &lt; patdk-lap&gt; cause normally you use clusters to handle it
03:46 &lt; multi_io&gt; brain fart on my part :P
03:47 &lt; Ganymede&gt; I wonder how much bandwidth worth of TCP keepalives a million connections would generate (also, are keepalives even necessary 
                  in the absence of NAT?)
03:47 &lt; p1mrx&gt; wait a minute, can't the "listen on a whole /64" thing be done with AnyIP? 
               http://kerneltrap.org/mailarchive/linux-netdev/2010/9/27/6285917
03:47 -!- mquin [~mquin@freenode/staff/mquin] has quit [Read error: Operation timed out]
03:47 &lt; patdk-lap&gt; ganymede, technically no, but they are still useful
03:47 &lt; patdk-lap&gt; wouldn't want my ssh connection open for weeks, when my laptop lost it's wifi connection
03:48 &lt; patdk-lap&gt; but then, I do want it open, if my laptop is working for weeks with ssh open
03:48 &lt; multi_io&gt; p1mrx: thanks, that's interesting 
03:49 &lt; Ganymede&gt; Speaking of which, sshfs never exits cleanly when the server disappears...it leaves any process accessing files on the sshfs 
                  mount hung so badly that kill -9 won't even kill it...
03:49 &lt; multi_io&gt; looks like that's what I mean :)

04:06 &lt; multi_io&gt; 03:43 &lt; Xenith&gt; Also, just because you have suddenly have a lot more IPs per network doesn't mean you'll suddenly have the 
                  same growth of simultaneous connections
04:06 &lt; multi_io&gt; That is of course correct; I know that listening to millions of IPs won't magically allow you to have more simultaneous actual 
                  connections. It would just allow you to accept connections or connectionless packets in a different wat (e.g. one per IP 
                  rather than one per port etc.)
04:07 &lt; multi_io&gt; ...and I was wondering whether this would make certain types of applications (which may not even be invented yet) easier to 
                  write in the future.
04:07 &lt; jercos&gt; Massively peer to peer mesh networks? &gt;.&gt;
04:07 &lt; multi_io&gt; that was the whole motivation behind my question
04:07 &lt; patdk-lap&gt; na, that doesn't help many people -&gt; service
04:07 &lt; patdk-lap&gt; that only increases the available connections from a SINGLE ip, to the service
04:08 &lt; patdk-lap&gt; if your using thousands of ip's from a single ip, I think your doing something wrong, probably
04:08 &lt; patdk-lap&gt; or your benchmarking

  </pre>

  <a href="."> back to ipv6 </a>

  <p/>

  <font size="-3">(C) 1998-2016 Olaf Klischat  &lt;olaf.klischat@gmail.com&gt; </font>

</body>

</html>
