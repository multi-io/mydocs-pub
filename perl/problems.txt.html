<html>
<!-- -*- html -*- -->





<head>
  <title> ./perl/problems.txt </title>
</head>

<body>

  <h1> <a href="../.">.</a>/<a href=".">perl</a>/problems.txt </h1>

  <a href="problems.txt">download original</a>

  <pre>
----
Array-Referenzen werden zu Hashreferenzen

  DB&lt;50&gt; @arr=(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)

  DB&lt;69&gt; x \{@arr}
0  SCALAR(0x91a4a94)
   -&gt; HASH(0x91a198c)
      0 =&gt; 1
      10 =&gt; 11
      12 =&gt; 13
      14 =&gt; 15
      2 =&gt; 3
      4 =&gt; 5
      6 =&gt; 7
      8 =&gt; 9
  DB&lt;70&gt; x \@arr    # this way it works as expected
0  ARRAY(0x919d7e4)
   0  0
   1  1
   2  2
   3  3
   4  4
   5  5
   6  6
   7  7
   8  8
   9  9
   10  10
   11  11
   12  12
   13  13
   14  14
   15  15
  DB&lt;71&gt; x {@arr}


  DB&lt;66&gt; $cpy= \{@arr[10..12]}

  DB&lt;67&gt; x $cpy
0  SCALAR(0x91a29cc)
   -&gt; HASH(0x91a2b70)
      10 =&gt; 11
      12 =&gt; undef
  DB&lt;68&gt; x $cpy-&gt;[0]
Not an ARRAY reference at (eval 89)[/usr/local/lib/perl5/5.6.0/perl5db.pl:1510] line 2, &lt;IN&gt; line 72.


How are slices implemented? Full-blown arrays created as (shallow)
copies of the specified section of the original array, or just a
pointer to the original array, plus two indizes?


  DB&lt;75&gt; $deepobj=[30,40,50,60]

  DB&lt;76&gt; 
main::(./tv_gui_regrtest.pl:61):	print "ALL TESTS SUCCESFUL.\n";
  DB&lt;76&gt; 
ALL TESTS SUCCESFUL.
Debugged program terminated.  Use q to quit or R to restart,
  use O inhibit_exit to avoid stopping after program termination,
  h q, h R or h O to get additional info.  
  DB&lt;76&gt; x $deepobj
0  ARRAY(0x91a6bac)
   0  30
   1  40
   2  50
   3  60
  DB&lt;77&gt; push @arr, $deepobj

  DB&lt;78&gt; push @arr, 42

  DB&lt;79&gt; push @arr, 43
  DB&lt;80&gt; x @arr
0  0
1  1
2  2
3  3
4  4
5  5
6  6
7  7
8  8
9  9
10  10
11  11
12  12
13  13
14  14
15  15
16  ARRAY(0x91a6bac)
   0  30
   1  40
   2  50
   3  60
17  42
18  43

  DB&lt;82&gt; x @cpy2=@arr[13..17]
0  13
1  14
2  15
3  ARRAY(0x91a6bac)
   0  30
   1  40
   2  50
   3  60
4  42
  DB&lt;83&gt; x push @$cpy2[2],70
Type of arg 1 to push must be array (not array slice) at (eval 104)[/usr/local/lib/perl5/5.6.0/perl5db.pl:1510] line 2, at EOF
  DB&lt;84&gt; x push @{$cpy2[2]},70
0  1
  DB&lt;85&gt; x @cpy2
0  13
1  14
2  15
3  ARRAY(0x91a6bac)
   0  30
   1  40
   2  50
   3  60
4  42
  DB&lt;86&gt; x push @{$cpy2[3]},70
0  5
  DB&lt;87&gt; x @cpy2
0  13
1  14
2  15
3  ARRAY(0x91a6bac)
   0  30
   1  40
   2  50
   3  60
   4  70
4  42
  DB&lt;88&gt; x @arr
0  0
1  1
2  2
3  3
4  4
5  5
6  6
7  7
8  8
9  9
10  10
11  11
12  12
13  13
14  14
15  15
16  ARRAY(0x91a6bac)
   0  30
   1  40
   2  50
   3  60
   4  70
17  42
18  43
  DB&lt;89&gt; 

----
Apparently "iterators" over arrays as established by e.g. "foreach"
are not part of the array itself:

  DB&lt;89&gt; @arr2=(0,1,2)

  DB&lt;91&gt; for $it1 (@arr2) { for $it2 (@arr2) { print "$it1 $it2   "; }}
0 0   0 1   0 2   1 0   1 1   1 2   2 0   2 1   2 2   

Is there a way to create and increment such iterators manually, or are
they an integrated part of the "foreach" magic?

----

how do you obtain a reference to a hash returned by a function call?

e.g.:

this gives me the hash returned by "map":

  DB&lt;126&gt; x map { ($_=&gt;1) } 6,8,3,4,2
0  6
1  1
2  8
3  1
4  3
5  1
6  4
7  1
8  2
9  1

same here (why doesn't this create a reference to the hash?)

  DB&lt;127&gt; x { map { ($_=&gt;1) } 6,8,3,4,2 }
0  6
1  1
2  8
3  1
4  3
5  1
6  4
7  1
8  2
9  1

but this gives me a reference to a reference to the hash!

  DB&lt;128&gt; x \{ map { ($_=&gt;1) } 6,8,3,4,2 }
0  REF(0x84dfb90)
   -&gt; HASH(0x84dc22c)
      2 =&gt; 1
      3 =&gt; 1
      4 =&gt; 1
      6 =&gt; 1
      8 =&gt; 1

And this doesn't work either:

  DB&lt;129&gt; x \ map { ($_=&gt;1) } 6,8,3,4,2
0  SCALAR(0x84e0a98)
   -&gt; 6
1  SCALAR(0x84dc250)
   -&gt; 1
2  SCALAR(0x84e4254)
   -&gt; 8
3  SCALAR(0x84de0cc)
   -&gt; 1
4  SCALAR(0x84e0b64)
   -&gt; 3
5  SCALAR(0x84e0d7c)
   -&gt; 1
6  SCALAR(0x84e0a74)
   -&gt; 4
7  SCALAR(0x84e4278)
   -&gt; 1
8  SCALAR(0x84dc004)
   -&gt; 2
9  SCALAR(0x84de1a4)
   -&gt; 1
  DB&lt;130&gt; 

it only works as expected when I create a temporary variable:

  DB&lt;130&gt; x %res=map { ($_=&gt;1) } 6,8,3,4,2; \%res
0  HASH(0x84e0c54)
   2 =&gt; 1
   3 =&gt; 1
   4 =&gt; 1
   6 =&gt; 1
   8 =&gt; 1
  DB&lt;131&gt; 

aaaah...

  DB&lt;141&gt; x +{ map {$_+3} 6,8,3,4,2,5 }
0  HASH(0x84e0cb4)
   5 =&gt; 8
   6 =&gt; 7
   9 =&gt; 11
  DB&lt;142&gt; 

(see "man perlref"/"making references"/3.)
----
----
----
----
----

  </pre>

  <a href="."> back to perl </a>

  <p/>

  <font size="-3">(C) 1998-2015 Olaf Klischat  &lt;olaf.klischat@gmail.com&gt; </font>

</body>

</html>
