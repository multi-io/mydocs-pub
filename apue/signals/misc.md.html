<p><small> <a href="../../.">.</a>/<a href="../.">apue</a>/<a href=".">signals</a>/misc.md <a href="misc.md">download original</a> </small></p>
<hr />
<pre><code>17:58 &lt; multi_io&gt; from APUE chapter 10 (signals): https://github.com/jivoi/junk/blob/master/apue-3e/signals/sleep2.c
17:58 &lt; multi_io&gt; how can longjmp() out of a signal handler work??
17:59 &lt; multi_io&gt; I thought the kernel needed to do special things after you return from a signal handler.
17:59 &lt; multi_io&gt; like, restore the previous context.
17:59 &lt; multi_io&gt; it looks to me like that longjmp would just return to sleep2 and then to sleep2&#39;s caller, all still in the &quot;context&quot; of the signal handler execution.
18:00 &lt; LiamW&gt; afaik signal handlers don&#39;t need to return
18:07 &lt; multi_io&gt; LiamW: how else would control be returned to the place where the signal suspended the main program&#39;s execution?
18:08 &lt; LiamW&gt; via vdso sigreturn
18:08 &lt; LiamW&gt; but if you don&#39;t call that it doesn&#39;t return
18:32  * multi_io reads sigreturn(2)</code></pre>
<p>NAME sigreturn, rt_sigreturn - return from signal handler and cleanup stack frame</p>
<p>SYNOPSIS int sigreturn(...);</p>
<p>DESCRIPTION</p>
<pre><code>   If the Linux kernel determines that an unblocked signal is
   pending for a process, then, at the next transition back to
   user mode in that process (e.g., upon return from a system call
   or when the process is rescheduled onto the CPU), it saves
   various pieces of process context (processor status word,
   registers, signal mask, and signal stack settings) into the
   user-space stack.

   The kernel also arranges that, during the transition back to
   user mode, the signal handler is called, and that, upon return
   from the handler, control passes to a piece of user-space code
   commonly called the &quot;signal trampoline&quot;.  The signal trampoline
   code in turn calls sigreturn().

   This sigreturn() call undoes everything that was done --
   changing the process&#39;s signal mask, switching signal stacks
   (see sigaltstack(2)) -- in order to invoke the signal handler.
   It restores the process&#39;s signal mask, switches stacks, and
   restores the process&#39;s context (processor flags and registers,
   including the stack pointer and instruction pointer), so that
   the process resumes execution at the point where it was
   interrupted by the signal.</code></pre>
<pre><code>20:00 &lt; multi_io&gt; does a vDSO function run in kernel mode or user mode?
20:00 &lt; sortie&gt; User-space
20:00 &lt; multi_io&gt; sortie: then what&#39;s the difference to a regular library function?
20:01 &lt; sortie&gt; Allows the kernel to decide at runtime
20:01 &lt; sortie&gt; The kernel can put code there that doesn&#39;t have any extra permissions, but it has knowledge of how to best do something
20:01 &lt; sortie&gt; For instance, to get the current time, it might know about a special kernel page that is read-only to user-space, but contains the current time. Saves a system call.
20:02 &lt; multi_io&gt; ok, so it IS technically a normal library function, just one that&#39;s provided by the kernel because it contains highly kernel-specific usermode code?
20:04 &lt; sortie&gt; Yes
20:05 &lt; sortie&gt; Which isn&#39;t really a normal library function
20:05 &lt; sortie&gt; But it is user-space code that libc knows how to find and use

20:48 &lt; multi_io&gt; so to come back to my question about signal handler invocations: the kernel only stores the main program&#39;s process state on the stack and transfers control to the handler and then forgets about it immediately?
20:48 &lt; multi_io&gt; i.e. it doesn&#39;t track a per-process &quot;currently executing a signal handler&quot; state

(and restoring the process state and transferring control back to the
place where the signal suspended the main program&#39;s execution -- if
desired -- would be done via sigreturn(2), i.e. in user space or at
least statelessly in kernel space)

20:51 &lt; sortie&gt; multi_io: That is correct
20:52 &lt; sortie&gt; multi_io: Though actually in my kernel, the kernel does keep a counter of how many signals have been delivered, and how many have been returned from. If both counters are equal and a signal is returned from, that means something is wrong, and my kernel
                aborts the process. The sigreturn system call loads every register and usually in a predictable location, so hackers like to use it, so I deny them that.
20:52 &lt; sortie&gt; But that&#39;s a constant amount of memory for N signals
20:58 &lt; multi_io&gt; sortie: thanks</code></pre>
<h2 id="eintr">EINTR</h2>
<p>(APUE 10.5)</p>
<p>Syscalls that may be interrupted by signals: open, close, read, write (to &quot;slow devices&quot; like terminals, not for disk I/O??), pause, some ioctls, Some of the interprocess communication functions.</p>
<p>Historically, implementations derived from System V fail the system call (with errno==EINTR), whereas BSD-derived implementations return partial success (e.g. read() returns a half-filled buffer). With the 2001 version of the POSIX.1 standard, the BSD-style semantics are required. To summarize:</p>
<ul>
<li><p>System V: abort with EINTR</p></li>
<li><p>POSIX: return partial success</p></li>
</ul>
<h3 id="automatic-syscall-restarts">Automatic Syscall Restarts</h3>
<p>To prevent applications from having to handle interrupted system calls, 4.2BSD introduced the automatic restarting of certain interrupted system calls. The system calls that were automatically restarted are ioctl, read, readv, write, writev, wait, and waitpid.</p>
<p>Since this caused a problem for some applications that didn’t want the operation restarted if it was interrupted, systems now allow the process to disable this feature on a per-signal basis (via the <code>SA_RESTART</code> flag to <code>sigaction</code>)</p>
<p>When using <code>signal</code> rather than <code>sigaction</code>:</p>
<ul>
<li><p>System V: no restart</p></li>
<li><p>Linux, FreeBSD, macOS: restart</p></li>
</ul>
<hr />
<p><small>© 1998-2017 Olaf Klischat <a href="mailto:olaf.klischat@gmail.com">olaf.klischat@gmail.com</a></small></p>
